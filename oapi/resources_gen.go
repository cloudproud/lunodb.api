// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ConnectorOptionType.
const (
	Boolean  ConnectorOptionType = "boolean"
	Integer  ConnectorOptionType = "integer"
	Password ConnectorOptionType = "password"
	String   ConnectorOptionType = "string"
)

// Defines values for QueryParamsLimit.
const (
	N0    QueryParamsLimit = 0
	N100  QueryParamsLimit = 100
	N1000 QueryParamsLimit = 1000
	N500  QueryParamsLimit = 500
)

// Catalog defines model for Catalog.
type Catalog struct {
	Description string    `json:"description"`
	Labels      *[]string `json:"labels"`
	Name        string    `json:"name"`
	Tables      Tables    `json:"tables"`
	Uid         string    `json:"uid"`
}

// CatalogTable defines model for CatalogTable.
type CatalogTable struct {
	// Name the table name referenced within SQL queries
	Name string          `json:"name"`
	Ref  CreateSourceRef `json:"ref"`

	// Schema the table schema referenced within SQL queries
	Schema string `json:"schema"`
}

// Catalogs defines model for Catalogs.
type Catalogs = []Catalog

// Column defines model for Column.
type Column struct {
	Name     string `json:"name"`
	Nullable bool   `json:"nullable"`
	Type     string `json:"type"`
}

// Connector defines model for Connector.
type Connector struct {
	Description string              `json:"description"`
	Id          string              `json:"id"`
	Name        string              `json:"name"`
	Options     [][]ConnectorOption `json:"options"`
}

// ConnectorOption defines model for ConnectorOption.
type ConnectorOption struct {
	Default     string              `json:"default"`
	Description string              `json:"description"`
	Key         string              `json:"key"`
	Name        string              `json:"name"`
	Placeholder string              `json:"placeholder"`
	Required    bool                `json:"required"`
	Type        ConnectorOptionType `json:"type"`
}

// ConnectorOptionType defines model for ConnectorOption.Type.
type ConnectorOptionType string

// Connectors defines model for Connectors.
type Connectors = []Connector

// CreateSourceRef defines model for CreateSourceRef.
type CreateSourceRef struct {
	Name  string   `json:"name"`
	Table TableRef `json:"table"`
}

// CustomConnector defines model for CustomConnector.
type CustomConnector struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Empty defines model for Empty.
type Empty = string

// Explain explain the executed query
type Explain struct {
	// Execution response time in ms
	Execution int `json:"execution"`

	// Planning response time in ms
	Planning int `json:"planning"`
}

// Key defines model for Key.
type Key struct {
	CreatedAt time.Time          `json:"created_at"`
	CreatedBy openapi_types.UUID `json:"created_by"`

	// Description Human-readable description
	Description string `json:"description"`

	// ExpiresAt Optional expiration timestamp
	ExpiresAt *time.Time `json:"expires_at"`

	// Id Unique identifier of the key
	Id       string   `json:"id"`
	Policies []Policy `json:"policies"`

	// Secret The API secret key
	Secret string `json:"secret"`
}

// Keys defines model for Keys.
type Keys = []Key

// NewSource defines model for NewSource.
type NewSource struct {
	// Connector represents the connector name used to connect with the given source
	Connector    string        `json:"connector"`
	ExposeGlobal bool          `json:"expose_global"`
	Name         string        `json:"name"`
	Options      SourceOptions `json:"options"`
}

// Policy defines model for Policy.
type Policy struct {
	Permissions []string `json:"permissions"`
	Resources   []string `json:"resources"`
}

// Problem defines model for Problem.
type Problem struct {
	// Detail A human readable explanation specific to this occurrence of the problem that is helpful to locate the problem and give advice on how to proceed. Written in English and readable for engineers, usually not suited for non technical stakeholders and not localized.
	Detail string `json:"detail"`

	// Title A short summary of the problem type. Written in English and readable for engineers, usually not suited for non technical stakeholders and not localized.
	Title string `json:"title"`
}

// Rows defines model for Rows.
type Rows struct {
	Columns []Column `json:"columns"`

	// Explain explain the executed query
	Explain Explain    `json:"explain"`
	Rows    [][]string `json:"rows"`
	Scope   []Scope    `json:"scope"`
}

// Scope defines model for Scope.
type Scope struct {
	Source ScopeRef   `json:"source"`
	Table  ScopeTable `json:"table"`
}

// ScopeRef defines model for ScopeRef.
type ScopeRef struct {
	Connector string `json:"connector"`
	Name      string `json:"name"`
	Schema    string `json:"schema"`
	Table     string `json:"table"`
}

// ScopeTable defines model for ScopeTable.
type ScopeTable struct {
	Name   string `json:"name"`
	Schema string `json:"schema"`
}

// SetCatalog defines model for SetCatalog.
type SetCatalog struct {
	Description string   `json:"description"`
	Labels      []string `json:"labels"`

	// Name the catalog name referenced within SQL queries
	Name   string         `json:"name"`
	Tables []CatalogTable `json:"tables"`
	Uid    string         `json:"uid"`
}

// Source defines model for Source.
type Source struct {
	// Connector represents the connector name used to connect with the given source
	Connector string `json:"connector"`
	Healthy   bool   `json:"healthy"`
	Name      string `json:"name"`
	Tables    Tables `json:"tables"`
	Uid       string `json:"uid"`
}

// SourceOptions defines model for SourceOptions.
type SourceOptions map[string]string

// SourceRef defines model for SourceRef.
type SourceRef struct {
	Id    string   `json:"id"`
	Name  string   `json:"name"`
	Table TableRef `json:"table"`
}

// Sources defines model for Sources.
type Sources = []Source

// Table defines model for Table.
type Table struct {
	Columns    []Column  `json:"columns"`
	Connector  string    `json:"connector"`
	Name       string    `json:"name"`
	Ref        Table_Ref `json:"ref"`
	Schema     string    `json:"schema"`
	Schemaless bool      `json:"schemaless"`
}

// Table_Ref defines model for Table.Ref.
type Table_Ref struct {
	union json.RawMessage
}

// TableRef defines model for TableRef.
type TableRef struct {
	// Name the table name referenced within SQL queries
	Name string `json:"name"`

	// Schema the table schema referenced within SQL queries
	Schema string `json:"schema"`
}

// Tables defines model for Tables.
type Tables = []Table

// UpdateSource defines model for UpdateSource.
type UpdateSource struct {
	Options SourceOptions `json:"options"`
}

// QueryParams defines parameters for Query.
type QueryParams struct {
	// Statements SQL query statements to be executed
	Statements string `form:"statements" json:"statements"`

	// Catalog Currently selected catalog
	Catalog string `form:"catalog" json:"catalog"`

	// Limit The total amount of rows to be returned
	Limit *QueryParamsLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Stream If true, the server will stream results using Server-Sent Events.
	Stream *bool `form:"stream,omitempty" json:"stream,omitempty"`
}

// QueryParamsLimit defines parameters for Query.
type QueryParamsLimit float32

// FetchSourceParams defines parameters for FetchSource.
type FetchSourceParams struct {
	// ExposeGlobal Update the globally exposed tables from the given source
	ExposeGlobal bool `form:"expose_global" json:"expose_global"`
}

// SetCatalogJSONRequestBody defines body for SetCatalog for application/json ContentType.
type SetCatalogJSONRequestBody = SetCatalog

// UpdateCatalogJSONRequestBody defines body for UpdateCatalog for application/json ContentType.
type UpdateCatalogJSONRequestBody = SetCatalog

// NewConnectorJSONRequestBody defines body for NewConnector for application/json ContentType.
type NewConnectorJSONRequestBody = CustomConnector

// NewKeyJSONRequestBody defines body for NewKey for application/json ContentType.
type NewKeyJSONRequestBody = Key

// NewSourceJSONRequestBody defines body for NewSource for application/json ContentType.
type NewSourceJSONRequestBody = NewSource

// TestSourceConnectionJSONRequestBody defines body for TestSourceConnection for application/json ContentType.
type TestSourceConnectionJSONRequestBody = NewSource

// UpdateSourceJSONRequestBody defines body for UpdateSource for application/json ContentType.
type UpdateSourceJSONRequestBody = UpdateSource

// AsSourceRef returns the union data inside the Table_Ref as a SourceRef
func (t Table_Ref) AsSourceRef() (SourceRef, error) {
	var body SourceRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceRef overwrites any union data inside the Table_Ref as the provided SourceRef
func (t *Table_Ref) FromSourceRef(v SourceRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceRef performs a merge with any union data inside the Table_Ref, using the provided SourceRef
func (t *Table_Ref) MergeSourceRef(v SourceRef) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableRef returns the union data inside the Table_Ref as a TableRef
func (t Table_Ref) AsTableRef() (TableRef, error) {
	var body TableRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableRef overwrites any union data inside the Table_Ref as the provided TableRef
func (t *Table_Ref) FromTableRef(v TableRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableRef performs a merge with any union data inside the Table_Ref, using the provided TableRef
func (t *Table_Ref) MergeTableRef(v TableRef) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Table_Ref) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Table_Ref) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConnector request
	GetConnector(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectors request
	GetConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCatalogWithBody request with any body
	SetCatalogWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCatalog(ctx context.Context, namespace string, body SetCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCatalog request
	DeleteCatalog(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalog request
	GetCatalog(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCatalogWithBody request with any body
	UpdateCatalogWithBody(ctx context.Context, namespace string, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCatalog(ctx context.Context, namespace string, catalog string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalogs request
	GetCatalogs(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewConnectorWithBody request with any body
	NewConnectorWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewConnector(ctx context.Context, namespace string, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKey request
	GetKey(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeys(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewKeyWithBody request with any body
	NewKeyWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewKey(ctx context.Context, namespace string, body NewKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Query request
	Query(ctx context.Context, namespace string, params *QueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewSourceWithBody request with any body
	NewSourceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewSource(ctx context.Context, namespace string, body NewSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSourceConnectionWithBody request with any body
	TestSourceConnectionWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSourceConnection(ctx context.Context, namespace string, body TestSourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSource request
	DeleteSource(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSource request
	GetSource(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSourceWithBody request with any body
	UpdateSourceWithBody(ctx context.Context, namespace string, source string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSource(ctx context.Context, namespace string, source string, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchSource request
	FetchSource(ctx context.Context, namespace string, source string, params *FetchSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourceOptions request
	GetSourceOptions(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSources request
	GetSources(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConnector(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCatalogWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCatalogRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCatalog(ctx context.Context, namespace string, body SetCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCatalogRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCatalog(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCatalogRequest(c.Server, namespace, catalog)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalog(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogRequest(c.Server, namespace, catalog)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalogWithBody(ctx context.Context, namespace string, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequestWithBody(c.Server, namespace, catalog, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalog(ctx context.Context, namespace string, catalog string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequest(c.Server, namespace, catalog, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalogs(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewConnectorWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewConnectorRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewConnector(ctx context.Context, namespace string, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewConnectorRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKey(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyRequest(c.Server, namespace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKey(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyRequest(c.Server, namespace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeys(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewKeyWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewKeyRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewKey(ctx context.Context, namespace string, body NewKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewKeyRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Query(ctx context.Context, namespace string, params *QueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSourceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSourceRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSource(ctx context.Context, namespace string, body NewSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSourceRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSourceConnectionWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSourceConnectionRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSourceConnection(ctx context.Context, namespace string, body TestSourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSourceConnectionRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSource(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSourceRequest(c.Server, namespace, source)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSource(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceRequest(c.Server, namespace, source)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceWithBody(ctx context.Context, namespace string, source string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequestWithBody(c.Server, namespace, source, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSource(ctx context.Context, namespace string, source string, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequest(c.Server, namespace, source, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchSource(ctx context.Context, namespace string, source string, params *FetchSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchSourceRequest(c.Server, namespace, source, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourceOptions(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceOptionsRequest(c.Server, namespace, source)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSources(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourcesRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConnectorRequest generates requests for GetConnector
func NewGetConnectorRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connector/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorsRequest generates requests for GetConnectors
func NewGetConnectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCatalogRequest calls the generic SetCatalog builder with application/json body
func NewSetCatalogRequest(server string, namespace string, body SetCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCatalogRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewSetCatalogRequestWithBody generates requests for SetCatalog with any type of body
func NewSetCatalogRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/catalog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCatalogRequest generates requests for DeleteCatalog
func NewDeleteCatalogRequest(server string, namespace string, catalog string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/catalog/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogRequest generates requests for GetCatalog
func NewGetCatalogRequest(server string, namespace string, catalog string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/catalog/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCatalogRequest calls the generic UpdateCatalog builder with application/json body
func NewUpdateCatalogRequest(server string, namespace string, catalog string, body UpdateCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCatalogRequestWithBody(server, namespace, catalog, "application/json", bodyReader)
}

// NewUpdateCatalogRequestWithBody generates requests for UpdateCatalog with any type of body
func NewUpdateCatalogRequestWithBody(server string, namespace string, catalog string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "catalog", runtime.ParamLocationPath, catalog)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/catalog/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCatalogsRequest generates requests for GetCatalogs
func NewGetCatalogsRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/catalogs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewConnectorRequest calls the generic NewConnector builder with application/json body
func NewNewConnectorRequest(server string, namespace string, body NewConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewConnectorRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewNewConnectorRequestWithBody generates requests for NewConnector with any type of body
func NewNewConnectorRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/connectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeyRequest generates requests for GetKey
func NewGetKeyRequest(server string, namespace string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/key/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteKeyRequest generates requests for DeleteKey
func NewDeleteKeyRequest(server string, namespace string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/key/%s/revoke", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewKeyRequest calls the generic NewKey builder with application/json body
func NewNewKeyRequest(server string, namespace string, body NewKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewKeyRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewNewKeyRequestWithBody generates requests for NewKey with any type of body
func NewNewKeyRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryRequest generates requests for Query
func NewQueryRequest(server string, namespace string, params *QueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statements", runtime.ParamLocationQuery, params.Statements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog", runtime.ParamLocationQuery, params.Catalog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stream != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream", runtime.ParamLocationQuery, *params.Stream); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewSourceRequest calls the generic NewSource builder with application/json body
func NewNewSourceRequest(server string, namespace string, body NewSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewSourceRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewNewSourceRequestWithBody generates requests for NewSource with any type of body
func NewNewSourceRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSourceConnectionRequest calls the generic TestSourceConnection builder with application/json body
func NewTestSourceConnectionRequest(server string, namespace string, body TestSourceConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSourceConnectionRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewTestSourceConnectionRequestWithBody generates requests for TestSourceConnection with any type of body
func NewTestSourceConnectionRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/test_connection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSourceRequest generates requests for DeleteSource
func NewDeleteSourceRequest(server string, namespace string, source string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "source", runtime.ParamLocationPath, source)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceRequest generates requests for GetSource
func NewGetSourceRequest(server string, namespace string, source string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "source", runtime.ParamLocationPath, source)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSourceRequest calls the generic UpdateSource builder with application/json body
func NewUpdateSourceRequest(server string, namespace string, source string, body UpdateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceRequestWithBody(server, namespace, source, "application/json", bodyReader)
}

// NewUpdateSourceRequestWithBody generates requests for UpdateSource with any type of body
func NewUpdateSourceRequestWithBody(server string, namespace string, source string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "source", runtime.ParamLocationPath, source)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchSourceRequest generates requests for FetchSource
func NewFetchSourceRequest(server string, namespace string, source string, params *FetchSourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "source", runtime.ParamLocationPath, source)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/%s/fetch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expose_global", runtime.ParamLocationQuery, params.ExposeGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceOptionsRequest generates requests for GetSourceOptions
func NewGetSourceOptionsRequest(server string, namespace string, source string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "source", runtime.ParamLocationPath, source)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/source/%s/options", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourcesRequest generates requests for GetSources
func NewGetSourcesRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/namespace/%s/sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConnectorWithResponse request
	GetConnectorWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error)

	// GetConnectorsWithResponse request
	GetConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsResponse, error)

	// SetCatalogWithBodyWithResponse request with any body
	SetCatalogWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCatalogResponse, error)

	SetCatalogWithResponse(ctx context.Context, namespace string, body SetCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCatalogResponse, error)

	// DeleteCatalogWithResponse request
	DeleteCatalogWithResponse(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*DeleteCatalogResponse, error)

	// GetCatalogWithResponse request
	GetCatalogWithResponse(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*GetCatalogResponse, error)

	// UpdateCatalogWithBodyWithResponse request with any body
	UpdateCatalogWithBodyWithResponse(ctx context.Context, namespace string, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error)

	UpdateCatalogWithResponse(ctx context.Context, namespace string, catalog string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error)

	// GetCatalogsWithResponse request
	GetCatalogsWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetCatalogsResponse, error)

	// NewConnectorWithBodyWithResponse request with any body
	NewConnectorWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error)

	NewConnectorWithResponse(ctx context.Context, namespace string, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error)

	// GetKeyWithResponse request
	GetKeyWithResponse(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*GetKeyResponse, error)

	// DeleteKeyWithResponse request
	DeleteKeyWithResponse(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error)

	// GetKeysWithResponse request
	GetKeysWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// NewKeyWithBodyWithResponse request with any body
	NewKeyWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewKeyResponse, error)

	NewKeyWithResponse(ctx context.Context, namespace string, body NewKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*NewKeyResponse, error)

	// QueryWithResponse request
	QueryWithResponse(ctx context.Context, namespace string, params *QueryParams, reqEditors ...RequestEditorFn) (*QueryResponse, error)

	// NewSourceWithBodyWithResponse request with any body
	NewSourceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSourceResponse, error)

	NewSourceWithResponse(ctx context.Context, namespace string, body NewSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*NewSourceResponse, error)

	// TestSourceConnectionWithBodyWithResponse request with any body
	TestSourceConnectionWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSourceConnectionResponse, error)

	TestSourceConnectionWithResponse(ctx context.Context, namespace string, body TestSourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSourceConnectionResponse, error)

	// DeleteSourceWithResponse request
	DeleteSourceWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error)

	// GetSourceWithResponse request
	GetSourceWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*GetSourceResponse, error)

	// UpdateSourceWithBodyWithResponse request with any body
	UpdateSourceWithBodyWithResponse(ctx context.Context, namespace string, source string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	UpdateSourceWithResponse(ctx context.Context, namespace string, source string, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	// FetchSourceWithResponse request
	FetchSourceWithResponse(ctx context.Context, namespace string, source string, params *FetchSourceParams, reqEditors ...RequestEditorFn) (*FetchSourceResponse, error)

	// GetSourceOptionsWithResponse request
	GetSourceOptionsWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*GetSourceOptionsResponse, error)

	// GetSourcesWithResponse request
	GetSourcesWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetSourcesResponse, error)
}

type GetConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Connector
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Connectors
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Catalog
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r SetCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalog
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Catalog
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalogs
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetCatalogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Source
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r NewConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Keys
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Key
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r NewKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rows
	JSON400      *Problem
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r QueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Source
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r NewSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSourceConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSON400      *Problem
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r TestSourceConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSourceConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON401      *Problem
	JSON404      *Problem
}

// Status returns HTTPResponse.Status
func (r GetSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON401      *Problem
	JSON404      *Problem
}

// Status returns HTTPResponse.Status
func (r UpdateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r FetchSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourceOptions
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetSourceOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sources
	JSON401      *Problem
}

// Status returns HTTPResponse.Status
func (r GetSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConnectorWithResponse request returning *GetConnectorResponse
func (c *ClientWithResponses) GetConnectorWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error) {
	rsp, err := c.GetConnector(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorResponse(rsp)
}

// GetConnectorsWithResponse request returning *GetConnectorsResponse
func (c *ClientWithResponses) GetConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsResponse, error) {
	rsp, err := c.GetConnectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorsResponse(rsp)
}

// SetCatalogWithBodyWithResponse request with arbitrary body returning *SetCatalogResponse
func (c *ClientWithResponses) SetCatalogWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCatalogResponse, error) {
	rsp, err := c.SetCatalogWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCatalogResponse(rsp)
}

func (c *ClientWithResponses) SetCatalogWithResponse(ctx context.Context, namespace string, body SetCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCatalogResponse, error) {
	rsp, err := c.SetCatalog(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCatalogResponse(rsp)
}

// DeleteCatalogWithResponse request returning *DeleteCatalogResponse
func (c *ClientWithResponses) DeleteCatalogWithResponse(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*DeleteCatalogResponse, error) {
	rsp, err := c.DeleteCatalog(ctx, namespace, catalog, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCatalogResponse(rsp)
}

// GetCatalogWithResponse request returning *GetCatalogResponse
func (c *ClientWithResponses) GetCatalogWithResponse(ctx context.Context, namespace string, catalog string, reqEditors ...RequestEditorFn) (*GetCatalogResponse, error) {
	rsp, err := c.GetCatalog(ctx, namespace, catalog, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogResponse(rsp)
}

// UpdateCatalogWithBodyWithResponse request with arbitrary body returning *UpdateCatalogResponse
func (c *ClientWithResponses) UpdateCatalogWithBodyWithResponse(ctx context.Context, namespace string, catalog string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error) {
	rsp, err := c.UpdateCatalogWithBody(ctx, namespace, catalog, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResponse(rsp)
}

func (c *ClientWithResponses) UpdateCatalogWithResponse(ctx context.Context, namespace string, catalog string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error) {
	rsp, err := c.UpdateCatalog(ctx, namespace, catalog, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResponse(rsp)
}

// GetCatalogsWithResponse request returning *GetCatalogsResponse
func (c *ClientWithResponses) GetCatalogsWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetCatalogsResponse, error) {
	rsp, err := c.GetCatalogs(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogsResponse(rsp)
}

// NewConnectorWithBodyWithResponse request with arbitrary body returning *NewConnectorResponse
func (c *ClientWithResponses) NewConnectorWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error) {
	rsp, err := c.NewConnectorWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewConnectorResponse(rsp)
}

func (c *ClientWithResponses) NewConnectorWithResponse(ctx context.Context, namespace string, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error) {
	rsp, err := c.NewConnector(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewConnectorResponse(rsp)
}

// GetKeyWithResponse request returning *GetKeyResponse
func (c *ClientWithResponses) GetKeyWithResponse(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*GetKeyResponse, error) {
	rsp, err := c.GetKey(ctx, namespace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyResponse(rsp)
}

// DeleteKeyWithResponse request returning *DeleteKeyResponse
func (c *ClientWithResponses) DeleteKeyWithResponse(ctx context.Context, namespace string, id string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error) {
	rsp, err := c.DeleteKey(ctx, namespace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyResponse(rsp)
}

// GetKeysWithResponse request returning *GetKeysResponse
func (c *ClientWithResponses) GetKeysWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeys(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeysResponse(rsp)
}

// NewKeyWithBodyWithResponse request with arbitrary body returning *NewKeyResponse
func (c *ClientWithResponses) NewKeyWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewKeyResponse, error) {
	rsp, err := c.NewKeyWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewKeyResponse(rsp)
}

func (c *ClientWithResponses) NewKeyWithResponse(ctx context.Context, namespace string, body NewKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*NewKeyResponse, error) {
	rsp, err := c.NewKey(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewKeyResponse(rsp)
}

// QueryWithResponse request returning *QueryResponse
func (c *ClientWithResponses) QueryWithResponse(ctx context.Context, namespace string, params *QueryParams, reqEditors ...RequestEditorFn) (*QueryResponse, error) {
	rsp, err := c.Query(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryResponse(rsp)
}

// NewSourceWithBodyWithResponse request with arbitrary body returning *NewSourceResponse
func (c *ClientWithResponses) NewSourceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSourceResponse, error) {
	rsp, err := c.NewSourceWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSourceResponse(rsp)
}

func (c *ClientWithResponses) NewSourceWithResponse(ctx context.Context, namespace string, body NewSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*NewSourceResponse, error) {
	rsp, err := c.NewSource(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSourceResponse(rsp)
}

// TestSourceConnectionWithBodyWithResponse request with arbitrary body returning *TestSourceConnectionResponse
func (c *ClientWithResponses) TestSourceConnectionWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSourceConnectionResponse, error) {
	rsp, err := c.TestSourceConnectionWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSourceConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestSourceConnectionWithResponse(ctx context.Context, namespace string, body TestSourceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSourceConnectionResponse, error) {
	rsp, err := c.TestSourceConnection(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSourceConnectionResponse(rsp)
}

// DeleteSourceWithResponse request returning *DeleteSourceResponse
func (c *ClientWithResponses) DeleteSourceWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error) {
	rsp, err := c.DeleteSource(ctx, namespace, source, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSourceResponse(rsp)
}

// GetSourceWithResponse request returning *GetSourceResponse
func (c *ClientWithResponses) GetSourceWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*GetSourceResponse, error) {
	rsp, err := c.GetSource(ctx, namespace, source, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceResponse(rsp)
}

// UpdateSourceWithBodyWithResponse request with arbitrary body returning *UpdateSourceResponse
func (c *ClientWithResponses) UpdateSourceWithBodyWithResponse(ctx context.Context, namespace string, source string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSourceWithBody(ctx, namespace, source, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceWithResponse(ctx context.Context, namespace string, source string, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSource(ctx, namespace, source, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

// FetchSourceWithResponse request returning *FetchSourceResponse
func (c *ClientWithResponses) FetchSourceWithResponse(ctx context.Context, namespace string, source string, params *FetchSourceParams, reqEditors ...RequestEditorFn) (*FetchSourceResponse, error) {
	rsp, err := c.FetchSource(ctx, namespace, source, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchSourceResponse(rsp)
}

// GetSourceOptionsWithResponse request returning *GetSourceOptionsResponse
func (c *ClientWithResponses) GetSourceOptionsWithResponse(ctx context.Context, namespace string, source string, reqEditors ...RequestEditorFn) (*GetSourceOptionsResponse, error) {
	rsp, err := c.GetSourceOptions(ctx, namespace, source, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceOptionsResponse(rsp)
}

// GetSourcesWithResponse request returning *GetSourcesResponse
func (c *ClientWithResponses) GetSourcesWithResponse(ctx context.Context, namespace string, reqEditors ...RequestEditorFn) (*GetSourcesResponse, error) {
	rsp, err := c.GetSources(ctx, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourcesResponse(rsp)
}

// ParseGetConnectorResponse parses an HTTP response from a GetConnectorWithResponse call
func ParseGetConnectorResponse(rsp *http.Response) (*GetConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConnectorsResponse parses an HTTP response from a GetConnectorsWithResponse call
func ParseGetConnectorsResponse(rsp *http.Response) (*GetConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Connectors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetCatalogResponse parses an HTTP response from a SetCatalogWithResponse call
func ParseSetCatalogResponse(rsp *http.Response) (*SetCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCatalogResponse parses an HTTP response from a DeleteCatalogWithResponse call
func ParseDeleteCatalogResponse(rsp *http.Response) (*DeleteCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogResponse parses an HTTP response from a GetCatalogWithResponse call
func ParseGetCatalogResponse(rsp *http.Response) (*GetCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCatalogResponse parses an HTTP response from a UpdateCatalogWithResponse call
func ParseUpdateCatalogResponse(rsp *http.Response) (*UpdateCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCatalogsResponse parses an HTTP response from a GetCatalogsWithResponse call
func ParseGetCatalogsResponse(rsp *http.Response) (*GetCatalogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseNewConnectorResponse parses an HTTP response from a NewConnectorWithResponse call
func ParseNewConnectorResponse(rsp *http.Response) (*NewConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetKeyResponse parses an HTTP response from a GetKeyWithResponse call
func ParseGetKeyResponse(rsp *http.Response) (*GetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeyResponse parses an HTTP response from a DeleteKeyWithResponse call
func ParseDeleteKeyResponse(rsp *http.Response) (*DeleteKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetKeysResponse parses an HTTP response from a GetKeysWithResponse call
func ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Keys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseNewKeyResponse parses an HTTP response from a NewKeyWithResponse call
func ParseNewKeyResponse(rsp *http.Response) (*NewKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseQueryResponse parses an HTTP response from a QueryWithResponse call
func ParseQueryResponse(rsp *http.Response) (*QueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/event-stream) unsupported

	}

	return response, nil
}

// ParseNewSourceResponse parses an HTTP response from a NewSourceWithResponse call
func ParseNewSourceResponse(rsp *http.Response) (*NewSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseTestSourceConnectionResponse parses an HTTP response from a TestSourceConnectionWithResponse call
func ParseTestSourceConnectionResponse(rsp *http.Response) (*TestSourceConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSourceConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteSourceResponse parses an HTTP response from a DeleteSourceWithResponse call
func ParseDeleteSourceResponse(rsp *http.Response) (*DeleteSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSourceResponse parses an HTTP response from a GetSourceWithResponse call
func ParseGetSourceResponse(rsp *http.Response) (*GetSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSourceResponse parses an HTTP response from a UpdateSourceWithResponse call
func ParseUpdateSourceResponse(rsp *http.Response) (*UpdateSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFetchSourceResponse parses an HTTP response from a FetchSourceWithResponse call
func ParseFetchSourceResponse(rsp *http.Response) (*FetchSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSourceOptionsResponse parses an HTTP response from a GetSourceOptionsWithResponse call
func ParseGetSourceOptionsResponse(rsp *http.Response) (*GetSourceOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourceOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSourcesResponse parses an HTTP response from a GetSourcesWithResponse call
func ParseGetSourcesResponse(rsp *http.Response) (*GetSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a connector
	// (GET /v1/connector/{id})
	GetConnector(w http.ResponseWriter, r *http.Request, id string)
	// Fetch all available connectors
	// (GET /v1/connectors)
	GetConnectors(w http.ResponseWriter, r *http.Request)
	// Set a new catalog
	// (POST /v1/namespace/{namespace}/catalog)
	SetCatalog(w http.ResponseWriter, r *http.Request, namespace string)
	// Delete a single catalog
	// (DELETE /v1/namespace/{namespace}/catalog/{catalog})
	DeleteCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string)
	// Fetch all data sets within the given catalog
	// (GET /v1/namespace/{namespace}/catalog/{catalog})
	GetCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string)
	// Add a table to a catalog
	// (PUT /v1/namespace/{namespace}/catalog/{catalog})
	UpdateCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string)
	// Fetch all data catalogs
	// (GET /v1/namespace/{namespace}/catalogs)
	GetCatalogs(w http.ResponseWriter, r *http.Request, namespace string)
	// Register a new connector
	// (POST /v1/namespace/{namespace}/connectors)
	NewConnector(w http.ResponseWriter, r *http.Request, namespace string)
	// Fetch a API key
	// (GET /v1/namespace/{namespace}/key/{id})
	GetKey(w http.ResponseWriter, r *http.Request, namespace string, id string)
	// Revoke the given key
	// (DELETE /v1/namespace/{namespace}/key/{id}/revoke)
	DeleteKey(w http.ResponseWriter, r *http.Request, namespace string, id string)
	// Fetch all API keys
	// (GET /v1/namespace/{namespace}/keys)
	GetKeys(w http.ResponseWriter, r *http.Request, namespace string)
	// Register a new API key
	// (POST /v1/namespace/{namespace}/keys)
	NewKey(w http.ResponseWriter, r *http.Request, namespace string)
	// Interact with the data catalogs through SQL
	// (GET /v1/namespace/{namespace}/query)
	Query(w http.ResponseWriter, r *http.Request, namespace string, params QueryParams)
	// Create a new source
	// (POST /v1/namespace/{namespace}/source)
	NewSource(w http.ResponseWriter, r *http.Request, namespace string)
	// Test the source connection
	// (POST /v1/namespace/{namespace}/source/test_connection)
	TestSourceConnection(w http.ResponseWriter, r *http.Request, namespace string)
	// Delete a single catalog source
	// (DELETE /v1/namespace/{namespace}/source/{source})
	DeleteSource(w http.ResponseWriter, r *http.Request, namespace string, source string)
	// Fetch the source details within the given catalog
	// (GET /v1/namespace/{namespace}/source/{source})
	GetSource(w http.ResponseWriter, r *http.Request, namespace string, source string)
	// Update a given source
	// (PUT /v1/namespace/{namespace}/source/{source})
	UpdateSource(w http.ResponseWriter, r *http.Request, namespace string, source string)
	// Fetch the latest source tables and schemas
	// (GET /v1/namespace/{namespace}/source/{source}/fetch)
	FetchSource(w http.ResponseWriter, r *http.Request, namespace string, source string, params FetchSourceParams)
	// Fetch the source options within the given catalog
	// (GET /v1/namespace/{namespace}/source/{source}/options)
	GetSourceOptions(w http.ResponseWriter, r *http.Request, namespace string, source string)
	// Fetch all sources
	// (GET /v1/namespace/{namespace}/sources)
	GetSources(w http.ResponseWriter, r *http.Request, namespace string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get a connector
// (GET /v1/connector/{id})
func (_ Unimplemented) GetConnector(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available connectors
// (GET /v1/connectors)
func (_ Unimplemented) GetConnectors(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Set a new catalog
// (POST /v1/namespace/{namespace}/catalog)
func (_ Unimplemented) SetCatalog(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a single catalog
// (DELETE /v1/namespace/{namespace}/catalog/{catalog})
func (_ Unimplemented) DeleteCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all data sets within the given catalog
// (GET /v1/namespace/{namespace}/catalog/{catalog})
func (_ Unimplemented) GetCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add a table to a catalog
// (PUT /v1/namespace/{namespace}/catalog/{catalog})
func (_ Unimplemented) UpdateCatalog(w http.ResponseWriter, r *http.Request, namespace string, catalog string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all data catalogs
// (GET /v1/namespace/{namespace}/catalogs)
func (_ Unimplemented) GetCatalogs(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register a new connector
// (POST /v1/namespace/{namespace}/connectors)
func (_ Unimplemented) NewConnector(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a API key
// (GET /v1/namespace/{namespace}/key/{id})
func (_ Unimplemented) GetKey(w http.ResponseWriter, r *http.Request, namespace string, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Revoke the given key
// (DELETE /v1/namespace/{namespace}/key/{id}/revoke)
func (_ Unimplemented) DeleteKey(w http.ResponseWriter, r *http.Request, namespace string, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all API keys
// (GET /v1/namespace/{namespace}/keys)
func (_ Unimplemented) GetKeys(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register a new API key
// (POST /v1/namespace/{namespace}/keys)
func (_ Unimplemented) NewKey(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Interact with the data catalogs through SQL
// (GET /v1/namespace/{namespace}/query)
func (_ Unimplemented) Query(w http.ResponseWriter, r *http.Request, namespace string, params QueryParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new source
// (POST /v1/namespace/{namespace}/source)
func (_ Unimplemented) NewSource(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test the source connection
// (POST /v1/namespace/{namespace}/source/test_connection)
func (_ Unimplemented) TestSourceConnection(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a single catalog source
// (DELETE /v1/namespace/{namespace}/source/{source})
func (_ Unimplemented) DeleteSource(w http.ResponseWriter, r *http.Request, namespace string, source string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the source details within the given catalog
// (GET /v1/namespace/{namespace}/source/{source})
func (_ Unimplemented) GetSource(w http.ResponseWriter, r *http.Request, namespace string, source string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a given source
// (PUT /v1/namespace/{namespace}/source/{source})
func (_ Unimplemented) UpdateSource(w http.ResponseWriter, r *http.Request, namespace string, source string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the latest source tables and schemas
// (GET /v1/namespace/{namespace}/source/{source}/fetch)
func (_ Unimplemented) FetchSource(w http.ResponseWriter, r *http.Request, namespace string, source string, params FetchSourceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the source options within the given catalog
// (GET /v1/namespace/{namespace}/source/{source}/options)
func (_ Unimplemented) GetSourceOptions(w http.ResponseWriter, r *http.Request, namespace string, source string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all sources
// (GET /v1/namespace/{namespace}/sources)
func (_ Unimplemented) GetSources(w http.ResponseWriter, r *http.Request, namespace string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetConnector operation middleware
func (siw *ServerInterfaceWrapper) GetConnector(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConnector(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConnectors operation middleware
func (siw *ServerInterfaceWrapper) GetConnectors(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConnectors(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetCatalog operation middleware
func (siw *ServerInterfaceWrapper) SetCatalog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetCatalog(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteCatalog operation middleware
func (siw *ServerInterfaceWrapper) DeleteCatalog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameterWithOptions("simple", "catalog", chi.URLParam(r, "catalog"), &catalog, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "catalog", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCatalog(w, r, namespace, catalog)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCatalog operation middleware
func (siw *ServerInterfaceWrapper) GetCatalog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameterWithOptions("simple", "catalog", chi.URLParam(r, "catalog"), &catalog, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "catalog", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCatalog(w, r, namespace, catalog)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateCatalog operation middleware
func (siw *ServerInterfaceWrapper) UpdateCatalog(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "catalog" -------------
	var catalog string

	err = runtime.BindStyledParameterWithOptions("simple", "catalog", chi.URLParam(r, "catalog"), &catalog, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "catalog", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateCatalog(w, r, namespace, catalog)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCatalogs operation middleware
func (siw *ServerInterfaceWrapper) GetCatalogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCatalogs(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// NewConnector operation middleware
func (siw *ServerInterfaceWrapper) NewConnector(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NewConnector(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKey operation middleware
func (siw *ServerInterfaceWrapper) GetKey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKey(w, r, namespace, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteKey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteKey(w, r, namespace, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetKeys operation middleware
func (siw *ServerInterfaceWrapper) GetKeys(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetKeys(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// NewKey operation middleware
func (siw *ServerInterfaceWrapper) NewKey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NewKey(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Query operation middleware
func (siw *ServerInterfaceWrapper) Query(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryParams

	// ------------- Required query parameter "statements" -------------

	if paramValue := r.URL.Query().Get("statements"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "statements"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "statements", r.URL.Query(), &params.Statements)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "statements", Err: err})
		return
	}

	// ------------- Required query parameter "catalog" -------------

	if paramValue := r.URL.Query().Get("catalog"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "catalog"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "catalog", r.URL.Query(), &params.Catalog)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "catalog", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "stream" -------------

	err = runtime.BindQueryParameter("form", true, false, "stream", r.URL.Query(), &params.Stream)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stream", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Query(w, r, namespace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// NewSource operation middleware
func (siw *ServerInterfaceWrapper) NewSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NewSource(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TestSourceConnection operation middleware
func (siw *ServerInterfaceWrapper) TestSourceConnection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TestSourceConnection(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DeleteSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSource(w, r, namespace, source)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSource operation middleware
func (siw *ServerInterfaceWrapper) GetSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSource(w, r, namespace, source)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateSource operation middleware
func (siw *ServerInterfaceWrapper) UpdateSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSource(w, r, namespace, source)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// FetchSource operation middleware
func (siw *ServerInterfaceWrapper) FetchSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params FetchSourceParams

	// ------------- Required query parameter "expose_global" -------------

	if paramValue := r.URL.Query().Get("expose_global"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "expose_global"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "expose_global", r.URL.Query(), &params.ExposeGlobal)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expose_global", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FetchSource(w, r, namespace, source, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSourceOptions operation middleware
func (siw *ServerInterfaceWrapper) GetSourceOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Path parameter "source" -------------
	var source string

	err = runtime.BindStyledParameterWithOptions("simple", "source", chi.URLParam(r, "source"), &source, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSourceOptions(w, r, namespace, source)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSources operation middleware
func (siw *ServerInterfaceWrapper) GetSources(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameterWithOptions("simple", "namespace", chi.URLParam(r, "namespace"), &namespace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSources(w, r, namespace)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/connector/{id}", wrapper.GetConnector)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/connectors", wrapper.GetConnectors)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/namespace/{namespace}/catalog", wrapper.SetCatalog)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/namespace/{namespace}/catalog/{catalog}", wrapper.DeleteCatalog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/catalog/{catalog}", wrapper.GetCatalog)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v1/namespace/{namespace}/catalog/{catalog}", wrapper.UpdateCatalog)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/catalogs", wrapper.GetCatalogs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/namespace/{namespace}/connectors", wrapper.NewConnector)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/key/{id}", wrapper.GetKey)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/namespace/{namespace}/key/{id}/revoke", wrapper.DeleteKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/keys", wrapper.GetKeys)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/namespace/{namespace}/keys", wrapper.NewKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/query", wrapper.Query)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/namespace/{namespace}/source", wrapper.NewSource)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/namespace/{namespace}/source/test_connection", wrapper.TestSourceConnection)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/namespace/{namespace}/source/{source}", wrapper.DeleteSource)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/source/{source}", wrapper.GetSource)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v1/namespace/{namespace}/source/{source}", wrapper.UpdateSource)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/source/{source}/fetch", wrapper.FetchSource)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/source/{source}/options", wrapper.GetSourceOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/namespace/{namespace}/sources", wrapper.GetSources)
	})

	return r
}
